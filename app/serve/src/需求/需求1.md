ç°åœ¨æˆ‘å¯¹ä½ çš„æ•´ä¸ªæ¶æ„æœ‰äº†ç†è§£ã€‚è®©æˆ‘ç»™ä½ è¯¦ç»†çš„å»ºè®®ï¼š    
   
  1ï¸âƒ£ LangGraph 1.0æ¨èå†™æ³• r                                     
  åœ¨ LangGraph 1.0 ä¸­ï¼Œå®˜æ–¹æ¨èæ˜¯ä¸¤å±‚ç­–ç•¥ï¼š                     
  // è½»ä¸šåŠ¡ â†’ ç”¨ createReactAgentï¼ˆå¿«é€Ÿï¼‰                    
  // å¤æ‚ä¸šåŠ¡ â†’ ç”¨ StateGraphï¼ˆæ·±åº¦å®šåˆ¶ï¼‰

  ä½ å½“å‰çš„åœºæ™¯å±äºå¤æ‚ä¸šåŠ¡ï¼ˆéœ€è¦æŒä¹…åŒ–è®°å¿†ã€å‘é‡åº“ã€è‡ªå®šä¹‰æµ 
  ç¨‹ï¼‰ï¼Œæ‰€ä»¥StateGraphæ˜¯å¯¹çš„ã€‚ä½†è¿˜å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ç»“æ„ã€‚       

  ---
  2 å½“å‰ä»£ç æ”¹è¿›æ–¹æ¡ˆ

  ä¸»è¦é—®é¢˜
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”        
  â”‚           é—®é¢˜            â”‚    å½±å“    â”‚ ä¼˜å…ˆçº§ â”‚        
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤        
  â”‚ æ•æ„Ÿä¿¡æ¯ç¡¬ç¼–ç åœ¨ä»£ç é‡Œ    â”‚ å®‰å…¨é£é™©   â”‚ ğŸ”´é«˜   â”‚        
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤        
  â”‚ æ²¡æœ‰é”™è¯¯é‡è¯•å’Œé™çº§        â”‚ ç”Ÿäº§ä¸ç¨³å®š â”‚ ğŸ”´é«˜   â”‚        
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤        
  â”‚ æ²¡æœ‰å¯è§‚æµ‹æ€§ï¼ˆæ—¥å¿—/ç›‘æ§ï¼‰ â”‚ éš¾ä»¥è°ƒè¯•   â”‚ ğŸ”´é«˜   â”‚        
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤        
  â”‚ HTTP Server æ²¡æœ‰ä¼˜é›…å…³é—­  â”‚ æ•°æ®ä¸¢å¤±   â”‚ ğŸŸ¡ä¸­   â”‚        
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤        
  â”‚ å·¥å…·æ‰§è¡Œæ²¡æœ‰è¶…æ—¶æ§åˆ¶      â”‚ å¯èƒ½å¡æ­»   â”‚ ğŸŸ¡ä¸­   â”‚        
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤        
  â”‚ æ²¡æœ‰é€Ÿç‡é™åˆ¶              â”‚ æ˜“è¢«æ»¥ç”¨   â”‚ ğŸŸ¡ä¸­   â”‚        
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤        
  â”‚ çŠ¶æ€ç®¡ç†ä¸å¤Ÿç»†ç²’åº¦        â”‚ éš¾ä»¥æ‰©å±•   â”‚ ğŸŸ¢ä½   â”‚        
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜        
  æ”¹è¿›ä»£ç æ¡†æ¶

  // agent.ts - é‡æ„ç‰ˆæœ¬
  import { ChatOllama } from "@langchain/ollama";
  import { PostgresChatMessageHistory } from
  "@langchain/community/stores/message/postgres";
  import http from "node:http";
  import querystring from "node:querystring";
  import { MessagesAnnotation, StateGraph, START, END,       
  Annotation } from "@langchain/langgraph";
  import { tools, toolNode } from "./embeddings/tool.js";    
  import { getAgentPrompt } from "./prompts/loader.js";      
  import { createLogger, getConfig } from "./utils/index.js";

  const logger = createLogger("agent");
  const config = getConfig();

  // âœ… æ”¹è¿›1: é…ç½®é›†ä¸­ç®¡ç†
  const llm = new ChatOllama({
    model: config.ollama.model,
    baseUrl: config.ollama.baseUrl,
    topP: config.ollama.topP,
    topK: config.ollama.topK,
    streaming: true,
    temperature: config.ollama.temperature,
    repeatPenalty: config.ollama.repeatPenalty,
    numPredict: config.ollama.numPredict,
    requestTimeout: 30000, // âœ… æ–°å¢: è¯·æ±‚è¶…æ—¶
  });

  const modelWithTools = llm.bindTools(tools);

  // âœ… æ”¹è¿›2: æ›´ç»†ç²’åº¦çš„çŠ¶æ€å®šä¹‰
  interface AgentState {
    messages: any[];
    userName: string;
    sessionId: string;
    summary?: string;
    toolCallCount: number;
    errors: string[];
  }

  const MyStateAnnotation = Annotation.Root({
    ...MessagesAnnotation.spec,
    userName: Annotation<string>({
      reducer: (oldV, newV) => newV ?? oldV,
      default: () => "è®¿å®¢",
    }),
    sessionId: Annotation<string>({
      reducer: (oldV, newV) => newV ?? oldV,
      default: () => "",
    }),
    summary: Annotation<string>({
      reducer: (old, next) => next ?? old,
    }),
    toolCallCount: Annotation<number>({
      reducer: (old, next) => next ?? old,
      default: () => 0,
    }),
    errors: Annotation<string[]>({
      reducer: (old, next) => [...(old || []), ...(next ||   
  [])],
      default: () => [],
    }),
  });

  // âœ… æ”¹è¿›3: åŠ å¼ºçš„æ¨¡å‹è°ƒç”¨
  async function callModel(state: typeof
  MyStateAnnotation.State) {
    try {
      let systemContent = getAgentPrompt({
        currentTime: new Date().toLocaleString(),
        userName: state.userName || "è®¿å®¢",
      });

      if (state.summary) {
        systemContent += `\n\n[å†å²å¯¹è¯æ‘˜è¦]:
  ${state.summary}`;
      }

      const systemPrompt = { role: "system", content:        
  systemContent };
      const recentMessages = state.messages.slice(-10);      

      logger.info(`[Model Call] ç”¨æˆ·: ${state.userName},     
  æ¶ˆæ¯æ•°: ${recentMessages.length}`);

      const response = await
  modelWithTools.invoke([systemPrompt, ...recentMessages]);  

      return {
        messages: [response],
        toolCallCount: state.toolCallCount +
  (response.tool_calls?.length || 0),
      };
    } catch (error: any) {
      logger.error(`[Model Error] ${error.message}`);        
      return {
        errors: [error.message],
        messages: [],
      };
    }
  }

  const workflow = new StateGraph(MyStateAnnotation)
    .addNode("agent", callModel)
    .addNode("tools", toolNode)
    .addEdge(START, "agent")
    .addConditionalEdges("agent", (state) => {
      const lastMessage =
  state.messages[state.messages.length - 1];
      const hasToolCalls = (lastMessage as
  any).tool_calls?.length;

      // âœ… æ”¹è¿›4: é™åˆ¶å·¥å…·è°ƒç”¨æ·±åº¦
      if (hasToolCalls && state.toolCallCount < 5) {
        return "tools";
      }
      return END;
    })
    .addEdge("tools", "agent");

  const appGraph = workflow.compile();

  // âœ… æ”¹è¿›5: è¿æ¥æ± ç®¡ç†
  const clients = new Map();

  async function getPostgresConnection(sessionId: string) {  
    if (!clients.has(sessionId)) {
      clients.set(sessionId, new PostgresChatMessageHistory({
        tableName: "chat_messages",
        sessionId,
        poolConfig: config.postgres,
      }));
    }
    return clients.get(sessionId);
  }

  // âœ… æ”¹è¿›6: è¯·æ±‚è§£æå¢å¼º
  async function parseRequestParams(req: any) {
    const query = req.url?.split("?")[1] ?
  querystring.parse(req.url.split("?")[1]) : {};
    let body = {};

    if (req.method === "POST") {
      return new Promise((resolve, reject) => {
        let rawBody = "";
        const timeout = setTimeout(() => reject(new
  Error("è¯·æ±‚è¶…æ—¶")), 30000);

        req.on("data", (chunk: any) => {
          rawBody += chunk;
          if (rawBody.length > 1024 * 1024) {
            clearTimeout(timeout);
            req.destroy();
            reject(new Error("è¯·æ±‚ä½“è¿‡å¤§"));
          }
        });

        req.on("end", () => {
          clearTimeout(timeout);
          try {
            body = JSON.parse(rawBody || "{}");
            resolve({ ...query, ...body });
          } catch (e) {
            reject(new Error("JSONè§£æå¤±è´¥"));
          }
        });

        req.on("error", reject);
      });
    }

    return { ...query, ...body };
  }

  // âœ… æ”¹è¿›7: ä¼˜é›…çš„æœåŠ¡å™¨åˆ›å»º
  const server = http.createServer(async (req, res) => {     
    if (req.url === "/favicon.ico") {
      res.writeHead(404);
      res.end();
      return;
    }

    // è·¨åŸŸè®¾ç½®
    res.setHeader("Access-Control-Allow-Origin", "*");       
    res.setHeader("Access-Control-Allow-Methods", "GET, POST,
   OPTIONS");
    res.setHeader("Access-Control-Allow-Headers",
  "Content-Type");

    if (req.method === "OPTIONS") {
      res.writeHead(204);
      res.end();
      return;
    }

    try {
      const params = (await parseRequestParams(req)) as      
  Record<string, string>;
      const sessionId = params.sessionId ||
  `session_${Date.now()}`;
      const user_input = params.user_input?.trim();

      if (!user_input) {
        res.writeHead(400);
        res.end(JSON.stringify({ error: "Missing user_input" 
  }));
        return;
      }

      res.writeHead(200, {
        "Content-Type": "text/event-stream; charset=utf-8",  
        "Cache-Control": "no-cache",
        "Connection": "keep-alive",
      });

      const history = await getPostgresConnection(sessionId);
      const allPrevMessages = await history.getMessages();   
      const prevMessages = allPrevMessages.slice(-5);        

      const stream = await appGraph.stream(
        {
          messages: [...prevMessages, { role: "user",        
  content: user_input }],
          sessionId,
          userName: params.userName || "è®¿å®¢",
        },
        {
          configurable: { sessionId },
          recursionLimit: 10,
        },
      );

      let finalContent = "";
      let hasError = false;

      for await (const chunk of stream) {
        const agentMsg = chunk.agent?.messages?.[0];
        if (agentMsg?.content) {
          const text = agentMsg.content;
          finalContent += text;
          res.write(`data: ${JSON.stringify({ content: text, 
  type: "text" })}\n\n`);
        }
        if (chunk.errors?.length) {
          hasError = true;
        }
      }

      if (!hasError) {
        await history.addUserMessage(user_input);
        if (finalContent) await
  history.addAIMessage(finalContent);
      }

      res.write(`data: ${JSON.stringify({ done: true,        
  hasError })}\n\n`);
      res.end();
    } catch (error: any) {
      logger.error("Server Error:", error);
      res.writeHead(500);
      res.end(JSON.stringify({ error: error.message }));     
    }
  });

  // âœ… æ”¹è¿›8: ä¼˜é›…å…³é—­
  const shutdown = async () => {
    logger.info("å¼€å§‹ä¼˜é›…å…³é—­...");
    server.close(() => {
      logger.info("æœåŠ¡å™¨å·²å…³é—­");
      process.exit(0);
    });

    // 30ç§’åå¼ºåˆ¶é€€å‡º
    setTimeout(() => {
      logger.warn("å¼ºåˆ¶é€€å‡º");
      process.exit(1);
    }, 30000);
  };

  process.on("SIGTERM", shutdown);
  process.on("SIGINT", shutdown);

  server.listen(config.port, () => {
    logger.info(`Agent æœåŠ¡å¯åŠ¨æˆåŠŸ:
  http://localhost:${config.port}/`);
  });

  ---
  3 ä¼ä¸šçº§Agentéœ€æ±‚ä¸å®Œæ•´æ–¹æ¡ˆ

  å‡å®šä¸€ä¸ªä¼ä¸šå‘˜å·¥ååŠ©AIåŠ©æ‰‹åœºæ™¯ï¼š

  éœ€æ±‚

  èƒŒæ™¯: æŸç§‘æŠ€å…¬å¸å†…éƒ¨éœ€è¦ä¸€ä¸ªAIåŠ©æ‰‹ï¼Œèƒ½å¤Ÿï¼š
  1. å¯¹å‘˜å·¥çš„å¸¸è§é—®é¢˜ï¼ˆå‡æœŸæ”¿ç­–ã€æŠ¥é”€æµç¨‹ã€æŠ€æœ¯æ–‡æ¡£ï¼‰è¿›è¡Œå¿«é€Ÿ
  å›ç­”
  2. è®°ä½å‘˜å·¥çš„åŸºæœ¬ä¿¡æ¯ï¼ˆéƒ¨é—¨ã€èŒçº§ã€é¡¹ç›®ï¼‰
  3. æ ¹æ®å‘˜å·¥èº«ä»½æ¨èç›¸å…³çš„ä¼ä¸šèµ„æº
  4. æ”¯æŒçŸ¥è¯†åº“çš„åŠ¨æ€æ›´æ–°ï¼ˆadminå¯ä»¥å®æ—¶æ–°å¢FAQï¼‰
  5. ç”Ÿæˆå®¡è®¡æ—¥å¿—ï¼ˆåˆè§„è¦æ±‚ï¼‰
  6. æ”¯æŒå¤šç§LLMåˆ‡æ¢ï¼ˆæˆæœ¬ä¼˜åŒ–ï¼‰

  å®Œæ•´ä¼ä¸šçº§æ¶æ„

  æˆ‘ç»™ä½ è®¾è®¡ä¸€ä¸ªå®Œæ•´çš„ç”Ÿäº§çº§æ–¹æ¡ˆã€‚è¿™ä¸ªæ–¹æ¡ˆå¾ˆå¤æ‚ï¼Œæˆ‘ä¼šåˆ†é˜¶æ®µ 
  ç»™ä½ ï¼š

  éœ€è¦åˆ›å»ºè¿™äº›æ–‡ä»¶ï¼š
  1. config.ts - é…ç½®ç®¡ç†
  2. types.ts - ç±»å‹å®šä¹‰
  3. database.ts - æ•°æ®åº“è¿æ¥
  4. memory.ts - å¢å¼ºçš„è®°å¿†ç³»ç»Ÿ
  5. tools/ - å¤šä¸ªå·¥å…·
  6. agents/ - Agent ç¼–æ’
  7. middleware.ts - HTTPä¸­é—´ä»¶
  8. server.ts - ä¸»æœåŠ¡å™¨

  ä½ è¦ä¸è¦æˆ‘ç»™ä½ å®Œæ•´çš„ä¼ä¸šçº§æ–¹æ¡ˆï¼Ÿè¿™æ ·å·¥ä½œé‡æ¯”è¾ƒå¤§ï¼Œä½†æˆ‘å¯ä»¥ 
  é€æ­¥ç”Ÿæˆã€‚ä½ æƒ³è¦ä»€ä¹ˆä¼˜å…ˆçº§çš„è¯¦ç»†ç¨‹åº¦ï¼Ÿ

  æˆ‘å¯ä»¥æä¾›ï¼š

  - A. å¿«é€Ÿç‰ˆ (1å°æ—¶å†…å®Œæˆ)
    - åŸºäºä½ ç°æœ‰ä»£ç çš„æœ€å°åŒ–æ”¹è¿›
    - é‡ç‚¹ï¼šé…ç½®ç®¡ç† + é”™è¯¯å¤„ç† + æ—¥å¿—
  - B. æ ‡å‡†ç‰ˆ (å®Œæ•´æ–¹æ¡ˆ)
    - å¤šå·¥å…·ç³»ç»Ÿï¼ˆçŸ¥è¯†åº“ã€å‘˜å·¥ä¿¡æ¯ã€èµ„æºæ¨èï¼‰
    - å®Œæ•´çš„è®¤è¯å’Œæƒé™ç®¡ç†
    - ç”Ÿäº§çº§ç›‘æ§å’Œå®¡è®¡æ—¥å¿—
  - C. é«˜çº§ç‰ˆ (ä¼ä¸šçº§)
    - Bçš„å…¨éƒ¨å†…å®¹ +
    - å¤šæ¨¡å‹æ™ºèƒ½è·¯ç”±ï¼ˆé€‰æ‹©æœ€ä¼˜çš„LLMï¼‰
    - å¤æ‚çš„Agentç¼–æ’ï¼ˆReAct + Plan-and-Executeæ··åˆï¼‰        
    - æ€§èƒ½ä¼˜åŒ–å’Œç¼“å­˜ç­–ç•¥
    - å®Œæ•´çš„å•æµ‹å’Œé›†æˆæµ‹è¯•

  ä½ å€¾å‘å“ªä¸ªæ–¹æ¡ˆï¼Ÿæˆ–è€…ä½ æœ‰å…¶ä»–å…·ä½“çš„ä¼ä¸šåœºæ™¯éœ€æ±‚å—ï¼Ÿ